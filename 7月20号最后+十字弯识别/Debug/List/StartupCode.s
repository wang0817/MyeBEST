///////////////////////////////////////////////////////////////////////////////
//                                                                            /
//                                                      10/Jan/2013  19:05:33 /
// IAR ANSI C/C++ Compiler V6.30.6.23336/W32 EVALUATION for ARM               /
// Copyright 1999-2012 IAR Systems AB.                                        /
//                                                                            /
//    Cpu mode     =  thumb                                                   /
//    Endian       =  little                                                  /
//    Source file  =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library /
//                    \CPU\StartupCode.c                                      /
//    Command line =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library /
//                    \CPU\StartupCode.c -D IAR -lCN                          /
//                    E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Debug\L /
//                    ist\ -lB E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ /
//                    \µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0. /
//                    3\Debug\List\ -o E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ /
//                    °Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\201301 /
//                    10\V0.0.3\Debug\Obj\ --no_cse --no_unroll --no_inline   /
//                    --no_code_motion --no_tbaa --no_clustering              /
//                    --no_scheduling --debug --endian=little                 /
//                    --cpu=Cortex-M4 -e --fpu=None --dlib_config             /
//                    D:\Tools\IAR6.30\arm\INC\c\DLib_Config_Normal.h -I      /
//                    E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library /
//                    \CPU\ -I E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ /
//                    \µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0. /
//                    3\Library\Drivers\ADC\ -I E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ /
//                    ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ /
//                    ÓÃ\20130110\V0.0.3\Library\Drivers\FTM\ -I              /
//                    E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library /
//                    \Drivers\GPIO\ -I E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µ /
//                    Ú°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130 /
//                    110\V0.0.3\Library\Drivers\PIT\ -Ol                     /
//    List file    =  E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇ /
//                    ÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Debug\L /
//                    ist\StartupCode.s                                       /
//                                                                            /
//                                                                            /
///////////////////////////////////////////////////////////////////////////////

        NAME StartupCode

        #define SHT_PROGBITS 0x1

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0
        SECTION `.data`:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0
        SECTION `.data_init`:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0
        SECTION CodeRelocate:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0
        SECTION CodeRelocateRam:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        EXTERN WriteVTOR_Kinetis
        EXTERN __VECTOR_RAM
        EXTERN __VECTOR_TABLE
        EXTERN main

        PUBLIC StartUp_Kinetis

// E:\¿ÎÍâ×ÊÁÏ\·ÉË¼¿¨¶ûÖÇÄÜ³µ\ÈÕ³£×ÊÁÏ\µÚ°Ë½ì×ÊÁÏ\µÚ°Ë½ìÖÇÄÜ³µ\Ö±Á¢³µµ÷ÊÔ\ARM\ARMÑ§Ï°Ê¹ÓÃ\20130110\V0.0.3\Library\CPU\StartupCode.c
//    1 /*******************************************************************************
//    2 * ÎÄ¼þÃû³Æ£ºStartupCode.c
//    3 * Ãè    Êö£º¶¨ÒåKinetisµÄ»ù±¾µ×²ã²Ù×÷º¯Êý(ÖÐ¶ÏµÄÉèÖÃÓëCPUÄ£Ê½µÄÉèÖÃ)¡£
//    4 
//    5 * ×÷    Õß£ºËïÎÄ½¡£¨Ô­×÷Õß£©
//    6 *           Íò±ù±ù£¨ÐÞ¸Ä£©
//    7 * ÌØ±ðÃùÐ»£º¼Í³ÉÊ¦ÐÖ(²©¿Íhttp://blog.chinaaet.com/jihceng0622)
//    8 * Ê±    ¼ä£º2012Äê5ÔÂ17ÈÕ
//    9 *******************************************************************************/
//   10 
//   11 #include "KinetisConfig.h"
//   12 
//   13 #pragma section = ".data"                        // Êý¾ÝÇøÓò
//   14 #pragma section = ".data_init"                   // ³õÊ¼»¯Êý¾ÝÇøÓò
//   15 #pragma section = ".bss"                         // ·Ç³õÊ¼»¯Êý¾ÝÇøÓò
//   16 #pragma section = "CodeRelocate"                 // ÖØ¶¨Î»´úÂëÇø
//   17 #pragma section = "CodeRelocateRam"              // ÖØ¶¨Î»RAMÇø
//   18 
//   19 /* Íâ²¿º¯ÊýÉùÃ÷ */
//   20 extern void main(void);                          // ÉùÃ÷ main º¯Êý
//   21 #if EN_InitHook_Kinetis != 0
//   22   extern void HOOK_BeforeClk_Kinetis(void);
//   23   extern void HOOK_AfterClk_Kinetis(void);
//   24 #endif
//   25 /* ±äÁ¿¶¨Òå */
//   26 #if EN_ResetType_Kinetis != 0
//   27   KEEP_Data_Kinetis int16u_t ResetType_Kinetis;  // ¸´Î»ÀàÐÍ
//   28 #endif
//   29 
//   30 
//   31 #if EN_CoreClkOut_Kinetis != 0
//   32 /******************************************************************************* 
//   33 * º¯ÊýÃû³Æ£ºOnCoreClk_Out
//   34 * Ãè    Êö£ºÓÃPTA6½ÅÊä³öÆµÂÊÎªCoreClockÆµÂÊ1/2µÄÊ±ÖÓÐÅºÅ
//   35 *******************************************************************************/
//   36 static void OnCoreClk_Out(void)
//   37 {
//   38     /* Set the trace clock to the core clock frequency */
//   39     SIM_SOPT2 |= SIM_SOPT2_TRACECLKSEL_MASK;
//   40     /* Enable the TRACE_CLKOUT pin function on PTA6 (alt7 function) */
//   41     PORTA_PCR6 = (PORT_PCR_MUX(7));
//   42 }
//   43 #endif 
//   44 
//   45 #if EN_FlexClkOut_Kinetis != 0
//   46 /******************************************************************************* 
//   47 * º¯ÊýÃû³Æ£ºOnFlexClk_Out
//   48 * Ãè    Êö£ºÓÃPTC3½ÅÊä³öFlexClock
//   49 ********************************************************************************/
//   50 static void OnFlexClk_Out(void)
//   51 {
//   52     /* Enable the clock to the FlexBus module */
//   53     SIM_SCGC7 |= SIM_SCGC7_FLEXBUS_MASK;
//   54     /* Enable the FB_CLKOUT function on PTC3 (alt5 function) */
//   55     PORTC_PCR3 = (PORT_PCR_MUX(5));
//   56 }
//   57 #endif
//   58 
//   59 #if EN_ResetType_Kinetis != 0
//   60 /*******************************************************************************
//   61 * º¯ÊýÃû³Æ£ºReadResetType_Kinetis
//   62 * Ãè    Êö£º¶ÁÈ¡¼Ä´æÆ÷ReadResetType_KinetisÒÔÅÐ¶¨ÏµÍ³µÄ¸´Î»ÀàÐÍ
//   63 ********************************************************************************/
//   64 static void ReadResetType_Kinetis(void)
//   65 {
//   66     ResetType_Kinetis = MC_SRSH;
//   67     ResetType_Kinetis <<= 8;
//   68     ResetType_Kinetis |= MC_SRSL;
//   69 }
//   70 #endif
//   71 
//   72 /******************************************************************************** 
//   73 * º¯ÊýÃû³Æ£ºDisWatchDog_Kinetis
//   74 * Ãè    Êö£º½ûÓÃ¿ªÃÅ¹·
//   75 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   76 static void DisWatchDog_Kinetis(void)
//   77 {
//   78     UNLOCK_WatchDog();                              // ½âËø¿ªÃÅ¹· 
DisWatchDog_Kinetis:
        LDR.N    R0,??DataTable7  ;; 0x4005200e
        MOVW     R1,#+50464
        STRH     R1,[R0, #+0]
        LDR.N    R0,??DataTable7  ;; 0x4005200e
        MOVW     R1,#+55592
        STRH     R1,[R0, #+0]
//   79     WDOG_STCTRLH &= ~WDOG_STCTRLH_WDOGEN_MASK;      // ½ûÓÃ¿ªÃÅ¹·
        LDR.N    R0,??DataTable7_1  ;; 0x40052000
        LDRH     R0,[R0, #+0]
        MOVW     R1,#+65534
        ANDS     R0,R1,R0
        LDR.N    R1,??DataTable7_1  ;; 0x40052000
        STRH     R0,[R1, #+0]
//   80 }
        BX       LR               ;; return
//   81 
//   82 /******************************************************************************** 
//   83 * º¯ÊýÃû³Æ£ºSetPLL_Kinetis
//   84 * Ãè    Êö£ºÏµÍ³µÄËøÏà»·Éè¶¨£¬ÆäÍê³ÉµÄÖ÷Òª¹¤×÷Îª£ºÉè¶¨CoreClock¡¢BusClock¡¢FlexClock¡¢FlashClock
//   85             (ÉèÖÃµÄ¾ßÌåÆµÂÊÔÚKinetisConfig.hÖÐÅäÖÃ)
//   86 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//   87 static void SetPLL_Kinetis(void)
//   88 {
//   89     int32u_t temp_reg;
//   90     int8u_t  i;
//   91     
//   92     // First move to FBE mode
//   93     // Enable external oscillator, RANGE=2, HGO=1, EREFS=1, LP=0, IRCS=0
//   94     MCG_C2 = MCG_C2_RANGE(1) | MCG_C2_HGO_MASK | MCG_C2_EREFS_MASK;
SetPLL_Kinetis:
        LDR.N    R0,??DataTable7_2  ;; 0x40064001
        MOVS     R1,#+28
        STRB     R1,[R0, #+0]
//   95 
//   96     // after initialization of oscillator release latched state of oscillator and GPIO
//   97     SIM_SCGC4 |= SIM_SCGC4_LLWU_MASK;
        LDR.N    R0,??DataTable7_3  ;; 0x40048034
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x10000000
        LDR.N    R1,??DataTable7_3  ;; 0x40048034
        STR      R0,[R1, #+0]
//   98     LLWU_CS |= LLWU_CS_ACKISO_MASK;
        LDR.N    R0,??DataTable7_4  ;; 0x4007c008
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x80
        LDR.N    R1,??DataTable7_4  ;; 0x4007c008
        STRB     R0,[R1, #+0]
//   99   
//  100     // Select external oscilator and Reference Divider and clear IREFS to start ext osc
//  101     // CLKS=2, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
//  102     MCG_C1 = MCG_C1_CLKS(2) | MCG_C1_FRDIV(3);
        LDR.N    R0,??DataTable7_5  ;; 0x40064000
        MOVS     R1,#+152
        STRB     R1,[R0, #+0]
//  103 
//  104     /* if we aren't using an osc input we don't need to wait for the osc to init */
//  105     // wait for Reference clock Status bit to clear
//  106     while (MCG_S & MCG_S_IREFST_MASK){};
??SetPLL_Kinetis_0:
        LDR.N    R0,??DataTable7_6  ;; 0x40064006
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+27
        BMI.N    ??SetPLL_Kinetis_0
//  107     // Wait for clock status bits to show clock source is ext ref clk
//  108     while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x2){}; 
??SetPLL_Kinetis_1:
        LDR.N    R0,??DataTable7_6  ;; 0x40064006
        LDRB     R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+2
        BNE.N    ??SetPLL_Kinetis_1
//  109 
//  110     /* Éè¶¨PLLÊ±ÖÓ */
//  111 #if CORE_CLK_Kinetis  <= 110
//  112     MCG_C5 = MCG_C5_PRDIV(REF_CLK_Kinetis/2 - 1);     // PLLCLK == 2MHz
        LDR.N    R0,??DataTable7_7  ;; 0x40064004
        MOVS     R1,#+3
        STRB     R1,[R0, #+0]
//  113 #else
//  114   #if   REF_CLK_Kinetis % 3 == 0
//  115     MCG_C5 = MCG_C5_PRDIV(REF_CLK_Kinetis/3 - 1);     // PLLCLK == 3MHz 
//  116   #elif REF_CLK_Kinetis % 4 == 0
//  117     MCG_C5 = MCG_C5_PRDIV(REF_CLK_Kinetis/4 - 1);     // PLLCLK == 4MHz 
//  118   #elif REF_CLK_Kinetis % 5 == 0
//  119     MCG_C5 = MCG_C5_PRDIV(REF_CLK_Kinetis*2/5 - 1);   // PLLCLK == 2.5MHz 
//  120   #endif
//  121 #endif 
//  122     
//  123     // Ensure MCG_C6 is at the reset default of 0. LOLIE disabled,
//  124     // PLL disabled, clk monitor disabled, PLL VCO divider is clear 
//  125     MCG_C6 = 0x00;
        LDR.N    R0,??DataTable7_8  ;; 0x40064005
        MOVS     R1,#+0
        STRB     R1,[R0, #+0]
//  126 
//  127     /* Éè¶¨¸÷Ê±ÖÓµÄ·ÖÆµÊý */
//  128     // store present value of FMC_PFAPR
//  129     temp_reg = FMC_PFAPR;
        LDR.N    R0,??DataTable7_9  ;; 0x4001f000
        LDR      R0,[R0, #+0]
//  130     // set M0PFD through M7PFD to 1 to disable prefetch
//  131     FMC_PFAPR |= FMC_PFAPR_M7PFD_MASK | FMC_PFAPR_M6PFD_MASK | FMC_PFAPR_M5PFD_MASK
//  132 		 | FMC_PFAPR_M4PFD_MASK | FMC_PFAPR_M3PFD_MASK | FMC_PFAPR_M2PFD_MASK
//  133 		 | FMC_PFAPR_M1PFD_MASK | FMC_PFAPR_M0PFD_MASK;
        LDR.N    R1,??DataTable7_9  ;; 0x4001f000
        LDR      R1,[R1, #+0]
        ORRS     R1,R1,#0xFF0000
        LDR.N    R2,??DataTable7_9  ;; 0x4001f000
        STR      R1,[R2, #+0]
//  134     // set clock dividers to desired value  
//  135     SIM_CLKDIV1 = SIM_CLKDIV1_OUTDIV1(0)       
//  136 	          | SIM_CLKDIV1_OUTDIV2(DIV_BusClk_Kinetis - 1) 
//  137 		  | SIM_CLKDIV1_OUTDIV3(DIV_FlexClk_Kinetis - 1) 
//  138 		  | SIM_CLKDIV1_OUTDIV4(DIV_FlashClk_Kinetis - 1);
        LDR.N    R1,??DataTable7_10  ;; 0x40048044
        LDR.N    R2,??DataTable7_11  ;; 0x1130000
        STR      R2,[R1, #+0]
//  139     // wait for dividers to change
//  140     for (i = 0 ; i < DIV_FlashClk_Kinetis ; i++) {}
        MOVS     R1,#+0
        B.N      ??SetPLL_Kinetis_2
??SetPLL_Kinetis_3:
        ADDS     R1,R1,#+1
??SetPLL_Kinetis_2:
        UXTB     R1,R1            ;; ZeroExt  R1,R1,#+24,#+24
        CMP      R1,#+4
        BCC.N    ??SetPLL_Kinetis_3
//  141     // re-store original value of FMC_PFAPR
//  142     FMC_PFAPR = temp_reg;   
        LDR.N    R1,??DataTable7_9  ;; 0x4001f000
        STR      R0,[R1, #+0]
//  143   
//  144     /* ÉèÖÃ±¶ÆµÊý,±¶ÆµÊýÎªVDIV+24 */
//  145 #if CORE_CLK_Kinetis  <= 110
//  146     MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(CORE_CLK_Kinetis/2 - 24); 
        LDR.N    R0,??DataTable7_8  ;; 0x40064005
        MOVS     R1,#+88
        STRB     R1,[R0, #+0]
//  147 #else
//  148   #if   REF_CLK_Kinetis % 3 == 0
//  149     MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(CORE_CLK_Kinetis/3 - 24); 
//  150   #elif REF_CLK_Kinetis % 4 == 0
//  151     MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(CORE_CLK_Kinetis/4 - 24);
//  152   #elif REF_CLK_Kinetis % 5 == 0
//  153     MCG_C6 = MCG_C6_PLLS_MASK | MCG_C6_VDIV(CORE_CLK_Kinetis*2/5 - 24); 
//  154   #endif
//  155 #endif
//  156   
//  157     while (!(MCG_S & MCG_S_PLLST_MASK)){};   // wait for PLL status bit to set
??SetPLL_Kinetis_4:
        LDR.N    R0,??DataTable7_6  ;; 0x40064006
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+26
        BPL.N    ??SetPLL_Kinetis_4
//  158     while (!(MCG_S & MCG_S_LOCK_MASK)){};    // Wait for LOCK bit to set
??SetPLL_Kinetis_5:
        LDR.N    R0,??DataTable7_6  ;; 0x40064006
        LDRB     R0,[R0, #+0]
        LSLS     R0,R0,#+25
        BPL.N    ??SetPLL_Kinetis_5
//  159 
//  160     // Now running PBE Mode
//  161     // Transition into PEE by setting CLKS to 0
//  162     // CLKS=0, FRDIV=3, IREFS=0, IRCLKEN=0, IREFSTEN=0
//  163     MCG_C1 &= ~MCG_C1_CLKS_MASK;
        LDR.N    R0,??DataTable7_5  ;; 0x40064000
        LDRB     R0,[R0, #+0]
        ANDS     R0,R0,#0x3F
        LDR.N    R1,??DataTable7_5  ;; 0x40064000
        STRB     R0,[R1, #+0]
//  164 
//  165     // Wait for clock status bits to update
//  166     while (((MCG_S & MCG_S_CLKST_MASK) >> MCG_S_CLKST_SHIFT) != 0x3){};
??SetPLL_Kinetis_6:
        LDR.N    R0,??DataTable7_6  ;; 0x40064006
        LDRB     R0,[R0, #+0]
        UBFX     R0,R0,#+2,#+2
        UXTB     R0,R0            ;; ZeroExt  R0,R0,#+24,#+24
        CMP      R0,#+3
        BNE.N    ??SetPLL_Kinetis_6
//  167 } 
        BX       LR               ;; return
//  168 
//  169 /*******************************************************************************
//  170 * º¯ÊýÃû³Æ£ºOnGPIOClk_Kinetis
//  171 * Ãè    Êö£ºÊ¹ÄÜGPIOÊ±ÖÓ 
//  172 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  173 static void OnGPIOClk_Kinetis(void)
//  174 {
//  175     /* Ê¹ÄÜIO¿ÚÊ±ÖÓ */
//  176     SIM_SCGC5 |= SIM_SCGC5_PORTA_MASK | SIM_SCGC5_PORTB_MASK
//  177 		 | SIM_SCGC5_PORTC_MASK | SIM_SCGC5_PORTD_MASK
//  178 		 | SIM_SCGC5_PORTE_MASK ;
OnGPIOClk_Kinetis:
        LDR.N    R0,??DataTable7_12  ;; 0x40048038
        LDR      R0,[R0, #+0]
        ORRS     R0,R0,#0x3E00
        LDR.N    R1,??DataTable7_12  ;; 0x40048038
        STR      R0,[R1, #+0]
//  179 }
        BX       LR               ;; return
//  180 
//  181 /******************************************************************************* 
//  182 * º¯ÊýÃû³Æ£ºInit_Clock_Kinetis
//  183 * Ãè    Êö£º³õÊ¼»¯ÏµÍ³Ê±ÖÓ,ÆäÍê³ÉµÄÖ÷Òª¹¤×÷ÓÐ£ºÉèÖÃÏµÍ³Ê±ÖÓ¡¢Ê¹ÄÜÍâ²¿»ù×¼Ê±ÖÓ¡¢½«ÏµÍ³Ê±ÖÓÍ¨¹ýIO¿ÚÊä³ö(¿ÉÑ¡) 
//  184 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  185 static void Init_Clock_Kinetis(void)
//  186 {      
Init_Clock_Kinetis:
        PUSH     {R7,LR}
//  187     SetPLL_Kinetis();                   // Éè¶¨ÏµÍ³Ê±ÖÓ 
        BL       SetPLL_Kinetis
//  188     OSC_CR |= OSC_CR_ERCLKEN_MASK;      // Ê¹ÄÜÍâ²¿»ù×¼Ê±ÖÓ(ºÜ¶àÄ£¿éÐèÒªÓÃµ½¸ÃÊ±ÖÓ)
        LDR.N    R0,??DataTable7_13  ;; 0x40065000
        LDRB     R0,[R0, #+0]
        ORRS     R0,R0,#0x80
        LDR.N    R1,??DataTable7_13  ;; 0x40065000
        STRB     R0,[R1, #+0]
//  189 	
//  190 #if  EN_CoreClkOut_Kinetis != 0
//  191     OnCoreClk_Out();                    // ÓÃPTA6Êä³öCoreClock/2
//  192 #endif
//  193 	
//  194 #if EN_FlexClkOut_Kinetis != 0	
//  195     OnFlexClk_Out();                    // ÓÃPTC3Êä³öFlexClock 
//  196 #endif
//  197 }
        POP      {R0,PC}          ;; return
//  198 
//  199 /*******************************************************************************
//  200 * º¯ÊýÃû³Æ£ºClearBss_Kinetis
//  201 * Ãè    Êö£º½«"BSS"Êý¾ÝÇø³õÊ¼»¯Îª0
//  202 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  203 static void ClearBss_Kinetis(void)
//  204 { 
//  205     int32u_t n = 0;  
ClearBss_Kinetis:
        MOVS     R0,#+0
//  206   
//  207     /* Get the addresses for the .bss section (zero-initialized data) */
//  208     int8u_t* __BSS_START = __section_begin(".bss");
        LDR.N    R1,??DataTable7_14
//  209     int8u_t* __BSS_END = __section_end(".bss");
        LDR.N    R2,??DataTable7_15
//  210     
//  211     /* Clear the zero-initialized data section */
//  212     n = __BSS_END - __BSS_START;
        SUBS     R2,R2,R1
        MOVS     R0,R2
        B.N      ??ClearBss_Kinetis_0
//  213     while(n--)
//  214       *__BSS_START++ = 0;   
??ClearBss_Kinetis_1:
        MOVS     R2,#+0
        STRB     R2,[R1, #+0]
        ADDS     R1,R1,#+1
??ClearBss_Kinetis_0:
        MOVS     R2,R0
        SUBS     R0,R2,#+1
        CMP      R2,#+0
        BNE.N    ??ClearBss_Kinetis_1
//  215 }
        BX       LR               ;; return
//  216 
//  217 /******************************************************************************* 
//  218 * º¯ÊýÃû³Æ£ºRomToRam_Kinetis
//  219 * Ãè    Êö£º½«²¿·ÖROMÖÐµÄÊý¾Ý×ªÒÆÖÁRAMÖÐ
//  220 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  221 static void RomToRam_Kinetis(void)
//  222 {
//  223     int32u_t n = 0;
RomToRam_Kinetis:
        MOVS     R0,#+0
//  224 
//  225     /* Get the addresses for the .data section (initialized data section) */
//  226     int8u_t* __DATA_RAM = __section_begin(".data");
        LDR.N    R1,??DataTable7_16
//  227     int8u_t* __DATA_ROM = __section_begin(".data_init");
        LDR.N    R2,??DataTable7_17
//  228     int8u_t* __DATA_ROM_END = __section_end(".data_init");
        LDR.N    R3,??DataTable7_18
//  229     
//  230     /* Copy initialized data from ROM to RAM */
//  231     n = __DATA_ROM_END - __DATA_ROM;
        SUBS     R3,R3,R2
        MOVS     R0,R3
        B.N      ??RomToRam_Kinetis_0
//  232     while(n--)
//  233       *__DATA_RAM++ = *__DATA_ROM++;
??RomToRam_Kinetis_1:
        LDRB     R3,[R2, #+0]
        STRB     R3,[R1, #+0]
        ADDS     R2,R2,#+1
        ADDS     R1,R1,#+1
??RomToRam_Kinetis_0:
        MOVS     R3,R0
        SUBS     R0,R3,#+1
        CMP      R3,#+0
        BNE.N    ??RomToRam_Kinetis_1
//  234 }
        BX       LR               ;; return
//  235 
//  236 /******************************************************************************* 
//  237 * º¯ÊýÃû³Æ£ºCodeRelocate_Kinetis
//  238 * Ãè    Êö£º¸´ÖÆÒÔ__ramfuncÉùÃ÷µÄ×Óº¯Êýµ½RAMÇø£¨CodeRelocateºÍCodeRelocateRamÕâÁ½¸ö¶¼¿ÉÒÔÔÚ.icfÎÄ¼þÀïÕÒµ½)
//  239 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  240 static void CodeRelocate_Kinetis(void)
//  241 {
//  242     int32u_t n = 0;
CodeRelocate_Kinetis:
        MOVS     R0,#+0
//  243   
//  244     /* Get addresses for any code sections that need to be copied from ROM to RAM.
//  245      * The IAR tools have a predefined keyword that can be used to mark individual
//  246      * functions for execution from RAM. Add "__ramfunc" before the return type in
//  247      * the function prototype for any routines you need to execute from RAM instead 
//  248      * of ROM. ex: __ramfunc void foo(void);
//  249     */
//  250     int8u_t* __CODE_RELOCATE_RAM = __section_begin("CodeRelocateRam");
        LDR.N    R1,??DataTable7_19
//  251     int8u_t* __CODE_RELOCATE = __section_begin("CodeRelocate");
        LDR.N    R2,??DataTable7_20
//  252     int8u_t* __CODE_RELOCATE_END = __section_end("CodeRelocate");
        LDR.N    R3,??DataTable7_21
//  253     
//  254     /* Copy functions from ROM to RAM */
//  255     n = __CODE_RELOCATE_END - __CODE_RELOCATE;
        SUBS     R3,R3,R2
        MOVS     R0,R3
        B.N      ??CodeRelocate_Kinetis_0
//  256     while(n--)
//  257       *__CODE_RELOCATE_RAM++ = *__CODE_RELOCATE++;    
??CodeRelocate_Kinetis_1:
        LDRB     R3,[R2, #+0]
        STRB     R3,[R1, #+0]
        ADDS     R2,R2,#+1
        ADDS     R1,R1,#+1
??CodeRelocate_Kinetis_0:
        MOVS     R3,R0
        SUBS     R0,R3,#+1
        CMP      R3,#+0
        BNE.N    ??CodeRelocate_Kinetis_1
//  258 }
        BX       LR               ;; return
//  259 
//  260 /*******************************************************************************
//  261 * º¯ÊýÃû³Æ£ºInit_VTOR_Kinetis
//  262 * Ãè    Êö£º³õÊ¼»¯ÖÐ¶ÏÏòÁ¿±í,½«ÏµÍ³Ä¬ÈÏµÄÖÐ¶ÏÏòÁ¿±í¸ÄÎª×Ô¶¨ÒÔµÄÖÐ¶ÏÏòÁ¿±í 
//  263 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(1)
        THUMB
//  264 static void Init_VTOR_Kinetis(void)
//  265 {     
Init_VTOR_Kinetis:
        PUSH     {R4,LR}
//  266     /* Addresses for VECTOR_TABLE and VECTOR_RAM come from the linker file */  
//  267     extern int32u_t __VECTOR_TABLE[];          // ÔÚ *.icf ÎÄ¼þÖÐ¶¨Òå
//  268     extern int32u_t __VECTOR_RAM[];            // ÔÚ *.icf ÎÄ¼þÖÐ¶¨Òå
//  269     
//  270     int32u_t n = 0;
        MOVS     R0,#+0
//  271     int32u_t *ptr1 , *ptr2;
//  272     
//  273     n = 120;
        MOVS     R1,#+120
        MOVS     R0,R1
//  274     ptr1 = __VECTOR_RAM;
        LDR.N    R1,??DataTable7_22
//  275     ptr2 = __VECTOR_TABLE;
        LDR.N    R2,??DataTable7_23
//  276     if (__VECTOR_RAM != __VECTOR_TABLE)        // ½«ÖÐ¶ÏÏòÁ¿±í¸´ÖÆµ½ RAM ÖÐ
        LDR.N    R3,??DataTable7_22
        LDR.N    R4,??DataTable7_23
        CMP      R3,R4
        BEQ.N    ??Init_VTOR_Kinetis_0
        B.N      ??Init_VTOR_Kinetis_1
//  277     {
//  278         while(n--)
//  279           *ptr1++ = *ptr2++;
??Init_VTOR_Kinetis_2:
        LDR      R3,[R2, #+0]
        STR      R3,[R1, #+0]
        ADDS     R2,R2,#+4
        ADDS     R1,R1,#+4
??Init_VTOR_Kinetis_1:
        MOVS     R3,R0
        SUBS     R0,R3,#+1
        CMP      R3,#+0
        BNE.N    ??Init_VTOR_Kinetis_2
//  280     }
//  281     /* Point the VTOR to the new copy of the vector table */
//  282     WriteVTOR_Kinetis((int32u_t)__VECTOR_RAM);
??Init_VTOR_Kinetis_0:
        LDR.N    R0,??DataTable7_22
        BL       WriteVTOR_Kinetis
//  283 }
        POP      {R4,PC}          ;; return

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7:
        DC32     0x4005200e

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_1:
        DC32     0x40052000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_2:
        DC32     0x40064001

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_3:
        DC32     0x40048034

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_4:
        DC32     0x4007c008

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_5:
        DC32     0x40064000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_6:
        DC32     0x40064006

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_7:
        DC32     0x40064004

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_8:
        DC32     0x40064005

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_9:
        DC32     0x4001f000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_10:
        DC32     0x40048044

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_11:
        DC32     0x1130000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_12:
        DC32     0x40048038

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_13:
        DC32     0x40065000

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_14:
        DC32     SFB(`.bss`)

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_15:
        DC32     SFE(`.bss`)

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_16:
        DC32     SFB(`.data`)

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_17:
        DC32     SFB(`.data_init`)

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_18:
        DC32     SFE(`.data_init`)

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_19:
        DC32     SFB(CodeRelocateRam)

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_20:
        DC32     SFB(CodeRelocate)

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_21:
        DC32     SFE(CodeRelocate)

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_22:
        DC32     __VECTOR_RAM

        SECTION `.text`:CODE:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
??DataTable7_23:
        DC32     __VECTOR_TABLE
//  284 
//  285 /*******************************************************************************
//  286 * º¯ÊýÃû³Æ£ºStartUp_Kinetis
//  287 * Ãè    Êö£ºKinetisµÄÆô¶¯´úÂë
//  288 *           ¼´ÏµÍ³ÉÏµçÊ±´¦ÀíÆ÷Ö´ÐÐµÄµÚÒ»¶Î´úÂë,¸ºÔðÍê³ÉARMËù±ØÐëµÄ³õÊ¼»¯²Ù×÷,²¢Ìø×ªµ½ÓÃ»§µÄÈë¿Ú³ÌÐò
//  289 *******************************************************************************/

        SECTION `.text`:CODE:NOROOT(2)
        THUMB
//  290 void StartUp_Kinetis(void)
//  291 {
StartUp_Kinetis:
        PUSH     {R7,LR}
//  292     DisableInterrupts();                  // ¹ØÖÐ¶Ï    
        CPSID i          
//  293     DisWatchDog_Kinetis();                // ½ûÓÃ¿´ÃÅ¹·  
        BL       DisWatchDog_Kinetis
//  294     OnGPIOClk_Kinetis();                  // ¿ªÆôGPIOÊ±ÖÓ 
        BL       OnGPIOClk_Kinetis
//  295     
//  296 #if EN_InitHook_Kinetis != 0      
//  297     HOOK_BeforeClk_Kinetis();             // Ö´ÐÐÓÃ»§¶¨ÒåµÄ³õÊ¼»¯½Ó¿Ú 
//  298 #endif
//  299 	
//  300     Init_Clock_Kinetis();                 // ³õÊ¼»¯ÏµÍ³Ê±ÖÓ 
        BL       Init_Clock_Kinetis
//  301 	
//  302 #if EN_InitHook_Kinetis != 0
//  303     HOOK_AfterClk_Kinetis();              // Ö´ÐÐÓÃ»§¶¨ÒåµÄ³õÊ¼»¯½Ó¿Ú 
//  304 #endif	
//  305   
//  306 #if EN_ResetType_Kinetis != 0  
//  307     ReadResetType_Kinetis();              // ¶ÁÈ¡¸´Î»ÀàÐÍ 
//  308 #endif	
//  309   
//  310     RomToRam_Kinetis();                   // ½«²¿·ÖROMÖÐµÄÊý¾Ý×ªÒÆµ½RAMÖÐ
        BL       RomToRam_Kinetis
//  311     CodeRelocate_Kinetis();               // ¸´ÖÆÒÔ__ramfuncÉùÃ÷µÄ×Óº¯Êýµ½RAMÇø
        BL       CodeRelocate_Kinetis
//  312     ClearBss_Kinetis();                   // ÇåÁãBSSÇøÓò 
        BL       ClearBss_Kinetis
//  313     Init_VTOR_Kinetis();                  // ³õÊ¼»¯ÖÐ¶ÏÏòÁ¿±í     
        BL       Init_VTOR_Kinetis
//  314 		
//  315     main();                               // Ìø×ªµ½mainº¯Êý 
        BL       main
//  316     while(1);                             // ³ÌÐò²»»áÖ´ÐÐµ½ÕâÀï
??StartUp_Kinetis_0:
        B.N      ??StartUp_Kinetis_0
//  317 }

        SECTION `.iar_vfe_header`:DATA:REORDER:NOALLOC:NOROOT(2)
        SECTION_TYPE SHT_PROGBITS, 0
        DATA
        DC32 0

        SECTION `.bss`:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION `.data`:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION `.data_init`:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION CodeRelocate:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION CodeRelocateRam:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        SECTION __DLIB_PERTHREAD_init:DATA:REORDER:NOROOT(0)
        SECTION_TYPE SHT_PROGBITS, 0

        END
// 
// 496 bytes in section .text
// 
// 496 bytes of CODE memory
//
//Errors: none
//Warnings: none
